# Retrospecting on Advent of Code 2017

------------

###### Monday January 15th, 2018

### Introduction

As a frame of reference, I'll be discussing my adventure through Advent of Code 2017, without explaining the event.
If you need more informations, I have two blog posts on the subject, which can be found [here](/blog/06-Using_Advent_of_Code_as_an_opportunity) and [there](/blog/14-Preparing_for_Advent_of_Code_2017).

This post will include keypoints I've learned through the project as well as random thoughts on the subject.

### Do It Everyday

I'm placing this at the top of the post as I believe it is the biggest takeaway I've gotten from AoC 2017.
It feels CRITICAL to treat Advent of Code as a daily task that cannot be delayed to a future day if you plan on completing it.

Although it may be anecdotal, I believe that the event should be treated the same way as forming any other habit.
Let up one day and it gets 1000 times harder to get back on track.

I've noticed it happen in 2015, when I got hardstuck on the Day 19's puzzle. I had a hard time keeping up afterwards and just gave up on day 21.
The same thing occured in 2016, as I decided to take a quick day off after messing with some code on Day 6. I never came back to it.
I've made sure to do every single problem daily this year, and never lost track of it.
I've also enrolled a friend this year, but the same thing occured for him.
I got stuck behind in the early days, and the mountain of days ahead demotivated him, rendering him unable to keep up.
I believe he got around 12 stars, the same amount I got in 2016.

### Do some early preparation

I won't go deep into the implementation of this year's preparation.
I've detailed most of it in my previous blog post (which was linked in the introduction).

However, I'll say that having this preparation was a great help throughout the event.
Not having to copy-paste input reading code for every day makes the code more concise, and easier to read.
It also saves a lot of time if you want to test the different examples provided by the problems.
This allows to write easy unit tests, which are easy to follow up on, easier to debug and save problem misunderstandings.

### Some days are harder than others

### Think ahead

### Enjoy yourself
